---
description: 
globs: 
alwaysApply: true
---
# Enterprise-Grade Development Guidelines

## Core Principles for AI-Assisted Development

This document establishes strict guidelines to ensure all AI-assisted development meets enterprise standards. These rules are non-negotiable and must be followed for any code generation, architecture decisions, or implementation guidance.

## 1. Code Quality Standards

### 1.1 Architecture Patterns
- **MUST** implement proper separation of concerns (data, presentation, business logic)
- **MUST** follow established design patterns appropriate to the platform (MVVM, Clean Architecture, etc.)
- **MUST** create modular, decoupled components that can be tested independently
- **MUST** implement dependency injection for all services and major components

### 1.2 Code Organization
- **MUST** use consistent file/folder structure following platform conventions
- **MUST** group related functionality logically
- **MUST** establish clear module boundaries with defined interfaces
- **MUST** implement proper error handling at all levels of the application

### 1.3 Coding Standards
- **MUST** follow language-specific best practices and style guides
- **MUST** write self-documenting code with clear naming conventions
- **MUST** avoid any "magic numbers" or hard-coded values
- **MUST** include appropriate comments for complex logic
- **MUST** handle all edge cases and potential failure points
- **MUST NOT** duplicate code (DRY principle)

## 2. Security Requirements

### 2.1 Authentication & Authorization
- **MUST** implement proper OAuth 2.0 flows or industry-standard authentication
- **MUST** use secure token handling and storage
- **MUST** implement proper role-based access control
- **MUST** validate all permissions server-side

### 2.2 Data Protection
- **MUST** encrypt sensitive data at rest and in transit
- **MUST** implement proper data validation on both client and server
- **MUST** use parameterized queries for all database operations
- **MUST** follow principle of least privilege for data access

### 2.3 Input/Output Security
- **MUST** sanitize all user inputs
- **MUST** validate all data types, ranges, and formats
- **MUST** implement protection against common vulnerabilities (XSS, CSRF, etc.)
- **MUST** use secure, vetted libraries for parsing data

## 3. Performance & Scalability

### 3.1 Resource Efficiency
- **MUST** optimize network calls (batching, pagination, caching)
- **MUST** implement proper state management to minimize renders/redraws
- **MUST** follow memory management best practices
- **MUST** optimize asset usage (images, bundle size, etc.)

### 3.2 Scalability Considerations
- **MUST** design for horizontal scaling
- **MUST** implement caching strategies where appropriate
- **MUST** handle asynchronous operations properly
- **MUST** design database schemas and queries for scale

## 4. Testing Requirements

### 4.1 Test Coverage
- **MUST** implement unit tests for business logic (min. 80% coverage)
- **MUST** implement integration tests for critical user flows
- **MUST** include UI component tests
- **MUST** implement API contract tests

### 4.2 Quality Assurance
- **MUST** include error boundary handling
- **MUST** handle offline/poor connectivity scenarios
- **MUST** implement proper logging for debugging
- **MUST** follow accessibility standards (WCAG 2.1 AA minimum)

## 5. Documentation Standards

### 5.1 Code Documentation
- **MUST** document all public interfaces and APIs
- **MUST** include inline documentation for complex algorithms
- **MUST** document known limitations or potential issues
- **MUST** maintain up-to-date README files for all modules

### 5.2 Architecture Documentation
- **MUST** document high-level architecture decisions
- **MUST** create data flow diagrams for complex operations
- **MUST** document authentication/authorization flows
- **MUST** provide environment setup instructions

## 6. Firebase-Specific Requirements

### 6.1 Database Structure
- **MUST** design optimized Firestore collections with proper indexing
- **MUST** implement appropriate security rules for all collections
- **MUST** avoid deeply nested data structures
- **MUST** minimize document reads/writes through efficient queries

### 6.2 Authentication
- **MUST** implement proper Firebase Authentication flows
- **MUST** handle token refresh and session management
- **MUST** implement robust error handling for auth operations
- **MUST** follow Firebase best practices for auth state persistence

### 6.3 Cloud Functions
- **MUST** implement proper error handling and retry logic
- **MUST** follow principle of atomic operations
- **MUST** handle transaction conflicts appropriately
- **MUST** implement proper logging and monitoring

## 7. Implementation Rules

### 7.1 Versioning & Compatibility
- **MUST** specify exact version numbers for all dependencies
- **MUST** ensure compatibility between all libraries and frameworks
- **MUST** document minimum platform/OS requirements
- **MUST** handle backward compatibility concerns

### 7.2 Error Prevention
- **MUST NOT** use deprecated APIs or libraries
- **MUST NOT** implement custom solutions for solved problems
- **MUST NOT** leave TODO comments in production code
- **MUST NOT** include test or mock data in production builds

## 8. AI Implementation Verification

Before accepting any AI-generated implementation:

1. **VERIFY** all code follows the standards above
2. **VERIFY** no placeholder implementations exist
3. **VERIFY** all edge cases are handled
4. **VERIFY** implementation follows current best practices, not outdated approaches
5. **VERIFY** all security concerns are properly addressed
6. **VERIFY** implementation is complete and not just a simplified example


Any deviation from these standards must be explicitly justified with a compelling technical reason.